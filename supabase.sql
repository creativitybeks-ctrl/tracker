-- same schema as before
create table if not exists profiles ( id uuid primary key references auth.users(id) on delete cascade, xp integer not null default 0, rp integer not null default 0, created_at timestamptz default now() );
create table if not exists quests ( id bigint generated by default as identity primary key, user_id uuid not null references auth.users(id) on delete cascade, title text not null, xp integer not null check (xp > 0), type text not null check (type in ('daily','routine','oneoff')), created_at timestamptz default now() );
create table if not exists completions ( id bigint generated by default as identity primary key, user_id uuid not null references auth.users(id) on delete cascade, quest_id bigint not null references quests(id) on delete cascade, date date not null, created_at timestamptz default now(), unique (user_id, quest_id, date) );
create or replace function handle_new_user() returns trigger as $$ begin insert into profiles (id) values (new.id); return new; end; $$ language plpgsql security definer;
drop trigger if exists on_auth_user_created on auth.users;
create trigger on_auth_user_created after insert on auth.users for each row execute procedure handle_new_user();
create or replace function gain_xp_rp(add_xp int, add_rp int) returns void as $$ begin update profiles set xp = xp + add_xp, rp = rp + add_rp where id = auth.uid(); end; $$ language plpgsql security definer;
create or replace function spend_rp(spend int) returns void as $$ begin update profiles set rp = rp - spend where id = auth.uid() and rp >= spend; end; $$ language plpgsql security definer;
alter table profiles enable row level security;
alter table quests enable row level security;
alter table completions enable row level security;
create policy "read own profile" on profiles for select using ( id = auth.uid() );
create policy "update own profile" on profiles for update using ( id = auth.uid() );
create policy "insert own quests" on quests for insert with check ( user_id = auth.uid() );
create policy "manage own quests select" on quests for select using ( user_id = auth.uid() );
create policy "manage own quests update" on quests for update using ( user_id = auth.uid() );
create policy "manage own quests delete" on quests for delete using ( user_id = auth.uid() );
create policy "insert own completion" on completions for insert with check ( user_id = auth.uid() );
create policy "manage own completion select" on completions for select using ( user_id = auth.uid() );
create policy "manage own completion update" on completions for update using ( user_id = auth.uid() );
create policy "manage own completion delete" on completions for delete using ( user_id = auth.uid() );
create or replace function set_user_id() returns trigger as $$ begin if new.user_id is null then new.user_id := auth.uid(); end if; return new; end; $$ language plpgsql;
drop trigger if exists set_user_id_on_quests on quests;
drop trigger if exists set_user_id_on_completions on completions;
create trigger set_user_id_on_quests before insert on quests for each row execute procedure set_user_id();
create trigger set_user_id_on_completions before insert on completions for each row execute procedure set_user_id();
